<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision$ -->
<!-- $Author$ -->
<!-- EN-Revision: 349700 Maintainer: Avenger Status: ready -->
<!-- CREDITS: Gregory, dallas -->
 <chapter xml:id="language.functions" xmlns="http://docbook.org/ns/docbook">
  <title>函数</title>

  <sect1 xml:id="functions.user-defined">
   <title>用户自定义函数</title>

   <para>
    一个函数可由以下的语法来定义：
   </para>
   <para>
    <example>
     <title>展示函数用途的伪代码</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo($arg_1, $arg_2, /* ..., */ $arg_n)
{
    echo "Example function.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>

   <simpara>
    任何有效的 PHP 代码都有可能出现在函数内部，甚至包括其它函数和 <link
    linkend="language.oop5.basic.class">类</link>定义。
   </simpara>
   <para>
    函数名和 PHP 中的其它标识符命名规则相同。有效的函数名以字母或下划线打头，后面跟字母，数字或下划线。可以用正则表达式表示为:
    <code>^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$</code>。
   </para>
   &tip.userlandnaming;
   <simpara>
    函数无需在调用之前被定义，<emphasis>除非</emphasis> 是下面两个例子中函数是有条件被定义时。
   </simpara>
   <para>
    当一个函数是有条件被定义时，必须在调用函数 <emphasis>之前</emphasis> 定义。
   </para>
   <para>
    <example>
     <title>有条件的函数</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* 不能在此处调用foo()函数，
   因为它还不存在，但可以调用bar()函数。*/

bar();

if ($makefoo) {
  function foo()
  {
    echo "I don't exist until program execution reaches me.\n";
  }
}

/* 现在可以安全调用函数 foo()了，
   因为 $makefoo 值为真 */

if ($makefoo) foo();

function bar()
{
  echo "I exist immediately upon program start.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   
   
   
   
   
   
   
   <para>
    <example>
     <title>函数中的函数</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
  function bar()
  {
    echo "I don't exist until foo() is called.\n";
  }
}

/* 现在还不能调用bar()函数，因为它还不存在 */

foo();

/* 现在可以调用bar()函数了，因为foo()函数
   的执行使得bar()函数变为已定义的函数 */

bar();

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    PHP 中的所有函数和类都具有全局作用域，可以定义在一个函数之内而在之外调用，反之亦然。
   </para>
   <simpara>
    PHP 不支持函数重载，也不可能取消定义或者重定义已声明的函数。
   </simpara>
   <note>
    <simpara>
     从 <literal>A</literal> 到 <literal>Z</literal>
     的 ASCII 函数名是大小写无关的，不过在调用函数的时候，使用其在定义时相同的形式是个好习惯。
    </simpara>
   </note>
   
   
   
   
   
   <simpara>
    PHP 的函数支持 <link linkend="functions.variable-arg-list">可变数量的参数</link> 和
    <link linkend="functions.arguments.default">默认参数</link>。参见
    <function>func_num_args</function>，<function>func_get_arg</function> 和 <function>func_get_args</function>。
   </simpara>

   
   
   
   <para>
    在 PHP 中可以调用递归函数。
    <example>
     <title>递归函数</title>
     <programlisting role="php">
<![CDATA[
<?php
function recursion($a)
{
    if ($a < 20) {
        echo "$a\n";
        recursion($a + 1);
    }
}
?>
]]>
     </programlisting>
    </example>
   <note>
    <simpara>
    但是要避免递归函数／方法调用超过
    100-200 层，因为可能会使堆栈崩溃从而使当前脚本终止。
    无限递归可视为编程错误。
    </simpara>
   </note>
   </para>
  </sect1>

  <sect1 xml:id="functions.arguments">
   <title>函数的参数</title>

   <simpara>
    通过参数列表可以传递信息到函数，即以逗号作为分隔符的表达式列表。参数是从左向右求值的。
   </simpara>
   
   
   
   
   <para>
    PHP 支持按值传递参数（默认），<link
    linkend="functions.arguments.by-reference">通过引用传递参数</link> 以及 <link
    linkend="functions.arguments.default">默认参数</link>。也支持 <link
    linkend="functions.variable-arg-list">可变长度参数列表</link>。
   </para>
   <para>
    <example>
     <title>向函数传递数组</title>
     <programlisting role="php">
<![CDATA[
<?php
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
?>
]]>
     </programlisting>
    </example>
   </para>

   
   <sect2 xml:id="functions.arguments.by-reference">
    <title>通过引用传递参数</title>

    <simpara>
     默认情况下，函数参数通过值传递（因而即使在函数内部改变参数的值，它并不会改变函数外部的值）。如果希望允许函数修改它的参数值，必须通过引用传递参数。
    </simpara>
    <para>
     如果想要函数的一个参数总是通过引用传递，可以在函数定义中该参数的前面加上符号 &amp;：
    </para>
    
    
    
    <para>
     <example>
      <title>用引用传递函数参数</title>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'and something extra.';
}
$str = 'This is a string, ';
add_some_extra($str);
echo $str;    // outputs 'This is a string, and something extra.'
?>
]]>
      </programlisting>
     </example>
    </para>

   </sect2>

   <sect2 xml:id="functions.arguments.default">
    <title>默认参数的值</title>

    <para>
     函数可以定义 C++ 风格的标量参数默认值，如下所示：
    </para>
    <para>
     <example>
      <title>在函数中使用默认参数</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($type = "cappuccino")
{
    return "Making a cup of $type.\n";
}
echo makecoffee();
echo makecoffee(null);
echo makecoffee("espresso");
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Making a cup of cappuccino.
Making a cup of .
Making a cup of espresso.
]]>
      </screen>
     </example>
    </para>
    <para>
     PHP 还允许使用数组 <type>array</type> 和特殊类型 &null; 作为默认参数，例如：
    </para>
    <para>
     <example>
      <title>使用非标量类型作为默认参数</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee($types = array("cappuccino"), $coffeeMaker = NULL)
{
    $device = is_null($coffeeMaker) ? "hands" : $coffeeMaker;
    return "Making a cup of ".join(", ", $types)." with $device.\n";
}
echo makecoffee();
echo makecoffee(array("cappuccino", "lavazza"), "teapot");
?>
]]>
      </programlisting>
     </example>
    </para>

    <simpara>
     默认值必须是常量表达式，不能是诸如变量，类成员，或者函数调用等。
    </simpara>
    <para>
     注意当使用默认参数时，任何默认参数必须放在任何非默认参数的右侧；否则，函数将不会按照预期的情况工作。考虑下面的代码片断：
    </para>
    
    
    <para>
     <example>
      <title>函数默认参数的不正确用法</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($type = "acidophilus", $flavour)
{
    return "Making a bowl of $type $flavour.\n";
}

echo makeyogurt("raspberry");   // won't work as expected
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41
Making a bowl of raspberry .
]]>
      </screen>
     </example>
    </para>
    <para>
     现在，比较上面的例子和这个例子：
    </para>
    <para>
     <example>
      <title>函数默认参数正确的用法</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt($flavour, $type = "acidophilus")
{
    return "Making a bowl of $type $flavour.\n";
}

echo makeyogurt("raspberry");   // works as expected
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Making a bowl of acidophilus raspberry.
]]>
      </screen>
     </example>
    </para>
    <note>
     <simpara>
      自 PHP 5 起，传引用的参数也可以有默认值。
     </simpara>
    </note>

   </sect2>

   <sect2 xml:id="functions.arguments.type-declaration">
    <title>类型声明</title>

    <note>
     <para>
      在 PHP 5 中，类型声明也被称为类型提示。
     </para>
    </note>

    <para>
     类型声明允许函数在调用时要求参数为特定类型。
     如果给出的值类型不对，那么将会产生一个错误：
     在 PHP 5 中，这将是一个可恢复的致命错误，而在 PHP 7 中将会抛出一个
     <classname>TypeError</classname> 异常。
    </para>

    <para>
     为了指定一个类型声明，类型应该加到参数名前。这个声明可以通过将参数的默认值设为 &null; 来实现允许传递 &null;。
    </para>

    <sect3 xml:id="functions.arguments.type-declaration.types">
     <title>有效类型</title>
     <informaltable>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>类型</entry>
         <entry>描述</entry>
         <entry>最小可用 PHP 版本</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>Class/interface name</entry>
         <entry>
          参数为指定类或接口的 &instanceof;。
         </entry>
         <entry>PHP 5.0.0</entry>
        </row>
        <row>
         <entry><literal>self</literal></entry>
         <entry>
          参数为当前类的 &instanceof;。可以为类或接口。
         </entry>
         <entry>PHP 5.0.0</entry>
        </row>
        <row>
         <entry><type>array</type></entry>
         <entry>
          参数必须为 <type>array</type>。
         </entry>
         <entry>PHP 5.1.0</entry>
        </row>
        <row>
         <entry><type>callable</type></entry>
         <entry>
          参数必须为有效的 <type>callable</type>。
         </entry>
         <entry>PHP 5.4.0</entry>
        </row>
        <row>
         <entry><type>bool</type></entry>
         <entry>
          参数必须为 <type>boolean</type> 值。
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>float</type></entry>
         <entry>
          参数必须为 <type>float</type> 浮点数。
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>int</type></entry>
         <entry>
          参数必须为 <type>integer</type>。
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><type>string</type></entry>
         <entry>
          参数必须为 <type>string</type>。
         </entry>
         <entry>PHP 7.0.0</entry>
        </row>
        <row>
         <entry><literal>iterable</literal></entry>
         <entry>
          参数必须为 <type>array</type> 或 <classname>Traversable</classname> 的 &instanceof;。
         </entry>
         <entry>PHP 7.1.0</entry>
        </row>
        <row>
         <entry><literal>object</literal></entry>
         <entry>
          参数必须为 <type>object</type>。
         </entry>
         <entry>PHP 7.2.0</entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
     
     <warning>
      <para>
       Aliases for the above scalar types are not supported. Instead, they are
       treated as class or interface names. For example, using
       <literal>boolean</literal> as a parameter or return type will require
       an argument or return value that is an &instanceof; the class or
       interface <literal>boolean</literal>, rather than of type
       <type>bool</type>:
      </para>
      <para>
       <example>
        <programlisting role="php">
 <![CDATA[
 <?php
 function test(boolean $param) {}
 test(true);
 ?>
 ]]>
        </programlisting>
        &example.outputs;
        <screen>
 <![CDATA[
 Fatal error: Uncaught TypeError: Argument 1 passed to test() must be an instance of boolean, boolean given, called in - on line 1 and defined in -:1
 ]]>
        </screen>
       </example>
      </para>
     </warning>
    </sect3>

    <sect3 xml:id="functions.arguments.type-declaration.examples">
     &reftitle.examples;
     <example>
      <title>基类类型声明</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}
class D extends C {}

// This doesn't extend C.
class E {}

function f(C $c) {
    echo get_class($c)."\n";
}

f(new C);
f(new D);
f(new E);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
C
D

Fatal error: Uncaught TypeError: Argument 1 passed to f() must be an instance of C, instance of E given, called in - on line 14 and defined in -:8
Stack trace:
#0 -(14): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
      </screen>
     </example>

     <example>
      <title>接口类类型声明</title>
      <programlisting role="php">
<![CDATA[
<?php
interface I { public function f(); }
class C implements I { public function f() {} }

// This doesn't implement I.
class E {}

function f(I $i) {
    echo get_class($i)."\n";
}

f(new C);
f(new E);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
C

Fatal error: Uncaught TypeError: Argument 1 passed to f() must implement interface I, instance of E given, called in - on line 13 and defined in -:8
Stack trace:
#0 -(13): f(Object(E))
#1 {main}
  thrown in - on line 8
]]>
      </screen>
     </example>

     <example>
      <title>Typed pass-by-reference Parameters</title>
      <simpara>
       Declared types of reference parameters are checked on function entry, but
       not when the function returns, so after the function had returned, the
       argument's type may have changed.
      </simpara>
      <programlisting role="php">
<![CDATA[
<?php
function array_baz(array &$param)
{
    $param = 1;
}
$var = [];
array_baz($var);
var_dump($var);
array_baz($var);
?>
]]>
      </programlisting>
      &example.outputs.similar;
      <screen>
<![CDATA[
int(1)

Fatal error: Uncaught TypeError: Argument 1 passed to array_baz() must be of the type array, int given, called in %s on line %d
]]>
      </screen>
     </example>
     <example>
      <title>可空类型声明</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

function f(C $c = null) {
    var_dump($c);
}

f(new C);
f(null);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
NULL
]]>
      </screen>
     </example>
    </sect3>

    <sect3 xml:id="functions.arguments.type-declaration.strict">
     <title>严格类型声明</title>

     <para>
      默认情况下，如果能做到的话，PHP 将会强迫错误类型的值转为函数期望的标量类型。
      例如，一个函数的一个参数期望是 <type>string</type>，但传入的是 <type>integer</type>，最终函数得到的将会是一个
      <type>string</type> 类型的值。
     </para>

     <para>
      可以基于每一个文件开启严格模式。在严格模式中，只有一个与类型声明完全相符的变量才会被接受，否则将会抛出一个
      <classname>TypeError</classname>。唯一的一个例外是可以将
      <type>integer</type> 传给一个期望 <type>float</type> 的函数。
     </para>

     <para>
      使用 &declare; 语句和 <literal>strict_types</literal> 声明来启用严格模式：
     </para>

     <caution>
      <para>
       启用严格模式同时也会影响 <link linkend="functions.returning-values.type-declaration">返回值类型声明</link>。
      </para>
     </caution>

     <note>
      <para>
       严格类型适用于在 <emphasis>启用严格模式的文件内</emphasis> 的函数调用，而不是在那个文件内声明的函数。
       一个没有启用严格模式的文件内调用了一个在启用严格模式的文件中定义的函数，那么将会遵循调用者的偏好（弱类型），而这个值将会被转换。
      </para>
     </note>

     <note>
      <para>
       严格类型仅用于标量类型声明，也正是因为如此，这需要 PHP 7.0.0 或更新版本，因为标量类型声明也是在那个版本中添加的。
      </para>
     </note>

     <example>
      <title>严格类型</title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1.5, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 9 and defined in -:4
Stack trace:
#0 -(9): sum(1.5, 2.5)
#1 {main}
  thrown in - on line 4
]]>
      </screen>
     </example>

     <example>
      <title>弱类型转换</title>
      <programlisting role="php">
<![CDATA[
<?php
function sum(int $a, int $b) {
    return $a + $b;
}

var_dump(sum(1, 2));

// These will be coerced to integers: note the output below!
var_dump(sum(1.5, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)
int(3)
]]>
      </screen>
     </example>

     <example>
      <title>捕捉 <classname>TypeError</classname></title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum(int $a, int $b) {
    return $a + $b;
}

try {
    var_dump(sum(1, 2));
    var_dump(sum(1.5, 2.5));
} catch (TypeError $e) {
    echo 'Error: '.$e->getMessage();
}
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)
Error: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 10
]]>
      </screen>
     </example>
    </sect3>
   </sect2>

   <sect2 xml:id="functions.variable-arg-list">
    <title>可变数量的参数列表</title>

    <simpara>
     PHP 在用户自定义函数中支持可变数量的参数列表。在 PHP 5.6 及以上的版本中，由
     <literal>...</literal> 语法实现；在 PHP 5.5 及更早版本中，使用函数
     <function>func_num_args</function>，<function>func_get_arg</function>，和
     <function>func_get_args</function> 。
    </simpara>
    <sect3 xml:id="functions.variable-arg-list.new">
     <title><literal>...</literal> in PHP 5.6+</title>

     <para>
      PHP 5.6 之后的版本中，包含
      <literal>...</literal> 的参数，会转换为指定参数变量的一个数组，见以下示例：

      <example>
       <title>使用 <literal>...</literal> 来访问变量参数</title>
       <programlisting role="php">
<![CDATA[
<?php
function sum(...$numbers) {
    $acc = 0;
    foreach ($numbers as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>

     <para>
      也可以使用 <literal>...</literal> 语法来传递 <type>array</type> 或
      <classname>Traversable</classname> 做为参数到函数中：

      <example>
       <title>使用 <literal>...</literal> 来传递参数</title>
       <programlisting role="php">
<![CDATA[
<?php
function add($a, $b) {
    return $a + $b;
}

echo add(...[1, 2])."\n";

$a = [1, 2];
echo add(...$a);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3
3
]]>
       </screen>
      </example>
     </para>

     <para>
      You may specify normal positional arguments before the
      <literal>...</literal> token. In this case, only the trailing arguments
      that don't match a positional argument will be added to the array
      generated by <literal>...</literal>.
     </para>

     <para>
      It is also possible to add a
      <link linkend="language.oop5.typehinting">type hint</link> before the
      <literal>...</literal> token. If this is present, then all arguments
      captured by <literal>...</literal> must be objects of the hinted class.

      <example>
       <title>输入提示的变量参数</title>
       <programlisting role="php">
<![CDATA[
<?php
function total_intervals($unit, DateInterval ...$intervals) {
    $time = 0;
    foreach ($intervals as $interval) {
        $time += $interval->$unit;
    }
    return $time;
}

$a = new DateInterval('P1D');
$b = new DateInterval('P2D');
echo total_intervals('d', $a, $b).' days';

// This will fail, since null isn't a DateInterval object.
echo total_intervals('d', null);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
3 days
Catchable fatal error: Argument 2 passed to total_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2
]]>
       </screen>
      </example>
     </para>

     <para>
      Finally, you may also pass variable arguments
      <link linkend="functions.arguments.by-reference">by reference</link> by
      prefixing the <literal>...</literal> with an ampersand
      (<literal>&amp;</literal>).
     </para>
    </sect3>

    <sect3 xml:id="functions.variable-arg-list.old">
     <title>旧版本的 PHP</title>

     <para>
      不需要特殊的语法来声明一个函数是可变的；但是访问函数的参数必须使用
      <function>func_num_args</function>, <function>func_get_arg</function>
      和 <function>func_get_args</function> 函数。
     </para>

     <para>
      上面的第一个例子在 PHP 5.5 和更早的版本中的实现如下：

      <example>
       <title>在 PHP 5.5 和更早的版本中访问可变参数</title>
       <programlisting role="php">
<![CDATA[
<?php
function sum() {
    $acc = 0;
    foreach (func_get_args() as $n) {
        $acc += $n;
    }
    return $acc;
}

echo sum(1, 2, 3, 4);
?>
]]>
       </programlisting>
       &example.outputs;
       <screen>
<![CDATA[
10
]]>
       </screen>
      </example>
     </para>
    </sect3>

   </sect2>

  </sect1>

  <sect1 xml:id="functions.returning-values">
   <title>返回值</title>

   <para>
    值通过使用可选的返回语句返回。可以返回包括数组和对象的任意类型。返回语句会立即中止函数的运行，并且将控制权交回调用该函数的代码行。更多信息见
    <function>return</function>。
   </para>
   <note>
    <para>
     如果省略了 <function>return</function>，则返回值为 &null;。
    </para>
   </note>
   
   
   <sect2>
     <title>return 的使用</title>
   <para>
    <example>
     <title><function>return</function> 的使用</title>
     <programlisting role="php">
<![CDATA[
<?php
function square($num)
{
    return $num * $num;
}
echo square(4);   // outputs '16'.
?>
]]>
     </programlisting>
     </example>
   </para>

   <para>
    函数不能返回多个值，但可以通过返回一个数组来得到类似的效果。
   </para>
   <para>
    <example>
     <title>返回一个数组以得到多个返回值</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
     </programlisting>
     </example>
   </para>
   <para>
    从函数返回一个引用，必须在函数声明和指派返回值给一个变量时都使用引用运算符 &amp;：
   </para>
   <para>
    <example>
     <title>从函数返回一个引用</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
     </example>
   </para>
   <simpara>
    有关引用的更多信息, 请查看 <link linkend="language.references">引用的解释</link>。
   </simpara>
   </sect2> 
   
   <sect2 xml:id="functions.returning-values.type-declaration">
   <title>返回值类型声明</title>

   <para>
    PHP 7 增加了对返回值类型声明的支持。 就如
    <link linkend="functions.arguments.type-declaration">类型声明</link> 一样,
    返回值类型声明将指定该函数返回值的类型。同样，返回值类型声明也与
    <link linkend="functions.arguments.type-declaration.types">有效类型</link>
    中可用的参数类型声明一致。
   </para>

   <para>
    <link linkend="functions.arguments.type-declaration.strict">严格类型声明</link>
    也会影响返回值类型声明。在默认情况下，如果返回值与返回值的类型不一致，则会被强制转换为返回值声明的类型，在强制转换失败的情况下才会抛出
    <classname>TypeError</classname> 异常（例如：函数预期返回 &array; 实际返回 &integer; 的情况，无法强制转换）。而在严格类型声明模式中，返回值的类型必须与预期一致，否则将会直接抛出
    <classname>TypeError</classname> 异常。
   </para>

   <para>
    从 PHP 7.1.0 开始，不指定类型的返回语句会导致一个 <constant>E_COMPILE_ERROR</constant>
    错误，除非指定了返回类型为 <type>void</type>，在此情况下，带有指定类型的返回会触发此错误。
   </para>
    
   <para>
    从 7.1.0 开始，返回值可以通过在类型前添加问号
    (<literal>?</literal>)
    来标记为允许返回空值。这表示该函数将返回指定类型或 &null;。
   </para>
    
   <note>
    <para>
     当覆盖一个父类方法时，子类方法的返回值类型声明必须与父类一致。如果父类方法没有定义返回类型，那么子类方法可以定义任意的返回值类型声明。
    </para>
   </note>

   <sect3 xml:id="functions.returning-values.type-declaration.examples">
    &reftitle.examples;

    <example>
     <title>基础返回值类型声明</title>
     <programlisting role="php">
<![CDATA[
<?php
function sum($a, $b): float {
    return $a + $b;
}

// Note that a float will be returned.
var_dump(sum(1, 2));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
float(3)
]]>
      </screen>
     </example>

     <example>
      <title>严格模式下执行</title>
      <programlisting role="php">
<![CDATA[
<?php
declare(strict_types=1);

function sum($a, $b): int {
    return $a + $b;
}

var_dump(sum(1, 2));
var_dump(sum(1, 2.5));
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
int(3)

Fatal error: Uncaught TypeError: Return value of sum() must be of the type integer, float returned in - on line 5 in -:5
Stack trace:
#0 -(9): sum(1, 2.5)
#1 {main}
  thrown in - on line 5
]]>
      </screen>
     </example>

     <example>
      <title>返回一个对象</title>
      <programlisting role="php">
<![CDATA[
<?php
class C {}

function getC(): C {
    return new C;
}

var_dump(getC());
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
object(C)#1 (0) {
}
]]>
      </screen>
     </example>

     <example>
      <title>指定可选返回空值 (PHP 7.1.0 起可用)</title>
      <programlisting role="php">
<![CDATA[
<?php
function get_item(): ?string {
    if (isset($_GET['item'])) {
        return $_GET['item'];
    } else {
        return null;
    }
}
?>
]]>
      </programlisting>
     </example>
    </sect3>
   </sect2> 
  </sect1>

  
  
  
  
  
  
  
  
  <sect1 xml:id="functions.variable-functions">
   <title>可变函数</title>

   <para>
    PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP
    将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。
    </para>
   <para>
    可变函数不能用于例如
    <function>echo</function>，<function>print</function>，<function>unset</function>，<function>isset</function>，<function>empty</function>，<function>include</function>，<function>require</function>
    以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。
   </para>
   <para>
    <example>
     <title>可变函数示例</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '') {
    echo "In bar(); argument was '$arg'.<br />\n";
}

// 使用 echo 的包装函数
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // This calls foo()

$func = 'bar';
$func('test');  // This calls bar()

$func = 'echoit';
$func('test');  // This calls echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    也可以用可变函数的语法来调用一个对象的方法。
    <example>
     <title>可变方法范例</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Variable()
    {
        $name = 'Bar';
        $this->$name(); // This calls the Bar() method
    }

    function Bar()
    {
        echo "This is Bar";
    }
}

$foo = new Foo();
$funcname = "Variable";
$foo->$funcname();   // This calls $foo->Variable()

?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    当调用静态方法时，函数调用要比静态属性优先：
    <example>
     <title>Variable 方法和静态属性示例</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static $variable = 'static property';
    static function Variable()
    {
        echo 'Method Variable called';
    }
}

echo Foo::$variable; // This prints 'static property'. It does need a $variable in this scope.
$variable = "Variable";
Foo::$variable();  // This calls $foo->Variable() reading $variable in this scope.

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
     PHP 5.4.0, you can call any <type>callable</type> stored in a variable.
    <example>
     <title>Complex callables</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    static function bar()
    {
        echo "bar\n";
    }
    function baz()
    {
        echo "baz\n";
    }
}

$func = array("Foo", "bar");
$func(); // prints "bar"
$func = array(new Foo, "baz");
$func(); // prints "baz"
$func = "Foo::bar";
$func(); // prints "bar" as of PHP 7.0.0; prior, it raised a fatal error
?>
]]>
     </programlisting>
    </example>
   </para>

   <para>
    参见 <function>is_callable</function>，<function>call_user_func</function>，<link
    linkend="language.variables.variable">可变变量</link>和
    <function>function_exists</function>。
   </para>
   
   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.0.0</entry>
         <entry>
          'ClassName::methodName' 允许为可变函数。
         </entry>
        </row>
        <row>
         <entry>5.4.0</entry>
         <entry>
          Arrays, which are valid callables, are allowed as variable functions.
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>
  </sect1>

  <sect1 xml:id="functions.internal">
     <title>内部（内置）函数</title>

     <para>
      PHP 有很多标准的函数和结构。还有一些函数需要和特定地 PHP
      扩展模块一起编译，否则在使用它们的时候就会得到一个致命的“未定义函数”错误。例如，要使用
      <link linkend="ref.image">image</link> 函数中的
      <function>imagecreatetruecolor</function>，需要在编译 PHP 的时候加上
      <productname>GD</productname> 的支持。或者，要使用
      <function>mysqli_connect</function> 函数，就需要在编译 PHP 的时候加上
      <link linkend="book.mysqli">MySQLi</link> 支持。有很多核心函数已包含在每个版本的
      PHP 中如<link linkend="ref.strings">字符串</link>和<link
      linkend="ref.var">变量</link>函数。调用
      <function>phpinfo</function> 或者 <function>get_loaded_extensions</function>
      可以得知 PHP 加载了那些扩展库。同时还应该注意，很多扩展库默认就是有效的。PHP
      手册按照不同的扩展库组织了它们的文档。请参阅<link
      linkend="configuration">配置</link>，<link
      linkend="install">安装</link>以及各自的扩展库章节以获取有关如何设置 PHP 的信息。
     </para>
     <para>
      手册中<link
      linkend="about.prototypes">如何阅读函数原型</link>讲解了如何阅读和理解一个函数的原型。确认一个函数将返回什么，或者函数是否直接作用于传递的参数是很重要的。例如，<function>str_replace</function>
      函数将返回修改过的字符串，而 <function>usort</function>
      却直接作用于传递的参数变量本身。手册中，每一个函数的页面中都有关于函数参数、行为改变、成功与否的返回值以及使用条件等信息。了解这些重要的（常常是细微的）差别是编写正确的
      PHP 代码的关键。
     </para>
   <note>
    <simpara>
     如果传递给函数的参数类型与实际的类型不一致，例如将一个 <type>array</type>
     传递给一个 <type>string</type> 类型的变量，那么函数的返回值是不确定的。在这种情况下，通常函数会返回
     &null;。但这仅仅是一个惯例，并不一定如此。
    </simpara>
   </note>    
     <para>
      参见 <function>function_exists</function>，<link
      linkend="funcref">函数参考</link>，<function>get_extension_funcs</function>
      和 <function>dl</function>。
     </para>
    </sect1>

  
  
  
  
  
  
  
  
  
  
  
  <sect1 xml:id="functions.anonymous">
   <title>匿名函数</title>

   <simpara>
    匿名函数（Anonymous functions），也叫闭包函数（<literal>closures</literal>），允许
    临时创建一个没有指定名称的函数。最经常用作回调函数 <type>callable</type>参数的值。当然，也有其它应用的情况。
   </simpara>
     
   <simpara>
    匿名函数目前是通过 <link linkend="class.closure">
    <classname>Closure</classname></link> 类来实现的。
   </simpara>

   <example>
    <title>匿名函数示例</title>
    <programlisting role="php">
<![CDATA[
<?php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world');
// 输出 helloWorld
?>
]]>
    </programlisting>
   </example>

   <simpara>
    闭包函数也可以作为变量的值来使用。PHP 会自动把此种表达式转换成内置类
    <classname>Closure</classname> 的对象实例。把一个 closure
    对象赋值给一个变量的方式与普通变量赋值的语法是一样的，最后也要加上分号：
   </simpara>

   <example>
    <title>匿名函数变量赋值示例</title>
    <programlisting role="php">
<![CDATA[
<?php
$greet = function($name)
{
    printf("Hello %s\r\n", $name);
};

$greet('World');
$greet('PHP');
?>
]]>
    </programlisting>
   </example>
   
   <simpara>
    闭包可以从父作用域中继承变量。
   任何此类变量都应该用 <literal>use</literal> 语言结构传递进去。 
    PHP 7.1 起，不能传入此类变量：  &link.superglobals;、 <varname>$this</varname> 或者和参数重名。
   </simpara>

   <example>
    <title>从父作用域继承变量</title>
    <programlisting role="php">
<![CDATA[
<?php
$message = 'hello';

// 没有 "use"
$example = function () {
    var_dump($message);
};
echo $example();

// 继承 $message
$example = function () use ($message) {
    var_dump($message);
};
echo $example();

// Inherited variable's value is from when the function
// is defined, not when called
$message = 'world';
echo $example();

// Reset message
$message = 'hello';

// Inherit by-reference
$example = function () use (&$message) {
    var_dump($message);
};
echo $example();

// The changed value in the parent scope
// is reflected inside the function call
$message = 'world';
echo $example();

// Closures can also accept regular arguments
$example = function ($arg) use ($message) {
    var_dump($arg . ' ' . $message);
};
$example("hello");
?>
]]>
    </programlisting>
    &example.outputs.similar;
    <screen>
<![CDATA[
Notice: Undefined variable: message in /example.php on line 6
NULL
string(5) "hello"
string(5) "hello"
string(5) "hello"
string(5) "world"
string(11) "hello world"
]]>
    </screen>
   </example>

     <simpara>
    这些变量都必须在函数或类的头部声明。
    
    从父作用域中继承变量与使用全局变量是<emphasis>不同</emphasis>的。全局变量存在于一个全局的范围，无论当前在执行的是哪个函数。而
    闭包的父作用域是定义该闭包的函数（不一定是调用它的函数）。示例如下：
   </simpara>

   <example>
    <title>Closures 和作用域</title>
    <programlisting role="php">
<![CDATA[
<?php
// 一个基本的购物车，包括一些已经添加的商品和每种商品的数量。
// 其中有一个方法用来计算购物车中所有商品的总价格，该方法使
// 用了一个 closure 作为回调函数。
class Cart
{
    const PRICE_BUTTER  = 1.00;
    const PRICE_MILK    = 3.00;
    const PRICE_EGGS    = 6.95;

    protected   $products = array();
    
    public function add($product, $quantity)
    {
        $this->products[$product] = $quantity;
    }
    
    public function getQuantity($product)
    {
        return isset($this->products[$product]) ? $this->products[$product] :
               FALSE;
    }
    
    public function getTotal($tax)
    {
        $total = 0.00;
        
        $callback =
            function ($quantity, $product) use ($tax, &$total)
            {
                $pricePerItem = constant(__CLASS__ . "::PRICE_" .
                    strtoupper($product));
                $total += ($pricePerItem * $quantity) * ($tax + 1.0);
            };
        
        array_walk($this->products, $callback);
        return round($total, 2);;
    }
}

$my_cart = new Cart;

// 往购物车里添加条目
$my_cart->add('butter', 1);
$my_cart->add('milk', 3);
$my_cart->add('eggs', 6);

// 打出出总价格，其中有 5% 的销售税.
print $my_cart->getTotal(0.05) . "\n";
// 最后结果是 54.29
?>
]]>
    </programlisting>
   </example>
     
     
   <example>
    <title>自动绑定 <literal>$this</literal></title>
    <programlisting role="php">
<![CDATA[
<?php

class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function();
    
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
object(Test)#1 (0) {
}
]]>
    </screen>
    &example.outputs.53;
    <screen>
<![CDATA[
Notice: Undefined variable: this in script.php on line 8
NULL]]>
    </screen>
   </example>
   
   <para>
    从 PHP 5.4.0 开始，当在类的上下文中声明时，当前的类会自动与之绑定，使得
    <literal>$this</literal> 在函数的作用域中可用。如果不需要当前类的自动绑定，可以使用
    <link linkend="functions.anonymous-functions.static">静态匿名函数</link> 替代。
   </para>
     <sect2 xml:id="functions.anonymous-functions.static">
    <title>静态匿名函数</title>
    <para>
     从 PHP 5.4 开始，匿名函数允许被定义为静态化。这样可以防止当前类自动绑定到它们身上，对象在运行时也可能不会被绑定到它们上面。
    </para>
    <para>
     <example>
      <title>试图在静态匿名函数中使用 <literal>$this</literal></title>
      <programlisting role="php">
<![CDATA[
<?php

class Foo
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);
        };
        $func();
    }
};
new Foo();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Notice: Undefined variable: this in %s on line %d
NULL
]]>
      </screen>
     </example>
    </para>

    <para>
     <example>
      <title>试图将对象绑定到静态匿名函数</title>
      <programlisting role="php">
<![CDATA[
<?php

$func = static function() {
    // function body
};
$func = $func->bindTo(new StdClass);
$func();

?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Warning: Cannot bind an instance to a static closure in %s on line %d
]]>
      </screen>
     </example>
    </para>
   </sect2>
     
   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.1.0</entry>
         <entry>
          Anonymous functions may not close over &link.superglobals;,
          <varname>$this</varname>, or any variable with the same name as a
          parameter.
         </entry>
        </row>
        <row>
         <entry>5.4.0</entry>
         <entry>
          <varname>$this</varname> 可用于匿名函数。
         </entry>
        </row>
        <row>
         <entry>5.3.0</entry>
         <entry>
          可以使用匿名函数。
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      可以在闭包中使用
      <function>func_num_args</function>，<function>func_get_arg</function>
      和 <function>func_get_args</function>。
     </simpara>
    </note>
   </sect2>

  </sect1>

  <sect1 xml:id="functions.arrow">
   <title>箭头函数</title>

   <simpara>
    箭头函数是 PHP 7.4 的新语法，是一种更简洁的
    <link linkend="functions.anonymous">匿名函数</link> 写法。
   </simpara>
   <simpara>
    匿名函数和箭头函数都是
    <link linkend="class.closure"><classname>Closure</classname></link> 类的实现。
   </simpara>

   <simpara>
    箭头函数的基本语法为
    <code>fn (argument_list) =&gt; expr</code>。
   </simpara>

   <simpara>
    箭头函数支持与 <link linkend="functions.anonymous">匿名函数</link>
    相同的功能，只是其父作用域的变量总是自动的。
   </simpara>

   <simpara>
    当表达式中使用的变量是在父作用域中定义的，它将被隐式地按值捕获。在下面的例子中，函数
    <varname>$fn1</varname> 和 <varname>$fn2</varname> 的行为是一样的。
   </simpara>

   <para>
    <example>
     <title>箭头函数自动捕捉变量的值</title>
     <programlisting role="php">
<![CDATA[
<?php

$y = 1;
 
$fn1 = fn($x) => $x + $y;
// 相当于 using $y by value:
$fn2 = function ($x) use ($y) {
    return $x + $y;
};

var_export($fn1(3));
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
4
]]>
      </screen>
    </example>
   </para>
   <simpara>
    在箭头函数嵌套的情况下同样有效。
   </simpara>
   <para>
    <example>
     <title>箭头函数自动捕捉变量的值，即使在嵌套的情况下</title>
     <programlisting role="php">
<![CDATA[
<?php

$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
// 输出 51
var_export($fn(5)(10));
?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    和匿名函数一样，箭头函数语法同样允许标准的函数声明，包括参数和返回类型、缺省值、变量，以及通过引用传递和返回。以下都是箭头函数的有效例子。
   </simpara>
   <para>
    <example>
     <title>合法的箭头函数例子</title>
     <programlisting role="php">
<![CDATA[
<?php

fn(array $x) => $x;
static fn(): int => $x;
fn($x = 42) => $x;
fn(&$x) => $x;
fn&($x) => $x;
fn($x, ...$rest) => $rest;

?>
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    箭头函数会自动绑定上下文变量，这相当于对箭头函数内部使用的每一个变量 <varname>$x</varname> 执行了一个
    <code>use($x)</code>。这意味着不可能修改外部作用域的任何值，若要实现对值的修改，可以使用
    <link linkend="functions.anonymous">匿名函数</link> 来替代。
   </simpara>
   <para>
    <example>
     <title>来自外部范围的值不能在箭头函数内修改</title>
     <programlisting role="php">
<![CDATA[
<?php

$x = 1;
$fn = fn() => $x++; // 不会影响 x 的值
$fn();
var_export($x);  // 输出 1

?>
]]>
     </programlisting>
    </example>
   </para>
   
   <sect2 role="changelog">
    &reftitle.changelog;
    <para>
     <informaltable>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>&Version;</entry>
         <entry>&Description;</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>7.4.0</entry>
         <entry>
          新增箭头函数语法。
         </entry>
        </row>
       </tbody>
      </tgroup>
     </informaltable>
    </para>
   </sect2>

   <sect2 role="notes">
    &reftitle.notes;
    <note>
     <simpara>
      可以对箭头函数使用 <function>func_num_args</function>,
      <function>func_get_arg</function>, 和 <function>func_get_args</function> 函数。
     </simpara>
    </note>
   </sect2>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
